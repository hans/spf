var attributes = ['shape', 'color'];

var shapes = ['sphere', 'cube', 'pyramid']
var colors = ['red', 'blue', 'green', 'black']
var properties = {shape: shapes, color: colors}

var terms = _.concat(shapes, colors)
var syntaxes = ['base', 'preN'];

var syntaxPrior = {
  "shape": Dirichlet({alpha: Vector([10, 1])}),
  "color": Dirichlet({alpha: Vector([1, 10])})
}
var termPrior = {
  "sphere": Dirichlet({alpha: ones([terms.length, 1])}),
  "cube": Dirichlet({alpha: ones([terms.length, 1])}),
  "pyramid": Dirichlet({alpha: ones([terms.length, 1])}),
  "red": Dirichlet({alpha: Vector([1,1,1,10,1,1,1])}),
  "blue": Dirichlet({alpha: Vector([1,1,1,1,10,1,1])}),
  "green": Dirichlet({alpha: Vector([1,1,1,1,10,1,1])}),
  "black": Dirichlet({alpha: ones([terms.length, 1])})
}

var query = function(querier) {return function() {
  // prior p(attribute type)
  var attr = Categorical({vs: attributes})

  // p(attribute value | attribute type) -- e.g. p(color | attribute type == color)
  var attrVal = mem(function(attr) {return Categorical({vs: properties[attr], ps: ones([properties[attr].length, 1])})})

  var term = mem(function(attrVal) {
    return Categorical({vs: terms, ps: sample(termPrior[attrVal])})
  })

  // p(syntax | attribute type)
  var syntax = mem(function(attr) {
    return Categorical({vs: syntaxes, ps: sample(syntaxPrior[attr])})
  })

  querier(attr, attrVal, term, syntax)
}}

var posterior = Infer({method: "SMC", particles: 100},
                     query(function(attr, attrVal, term, syntax) {
  var qAttr = sample(attr)
  var qAttrVal = sample(attrVal(qAttr))
  observe(term(qAttrVal), "black")
  observe(syntax(qAttr), "preN")
  return {attr: qAttr,
          attrVal: qAttrVal}
}))

JSON.stringify(map(function(val) {
  [val, posterior.score(val)]
}, posterior.support()))
